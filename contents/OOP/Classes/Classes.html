<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Classes and objects</title>
		<link rel="shortcut icon" type="image/x-icon" href="../../../../../KonoMngr/style/icons/konoicn.png">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../../../KonoMngr/style/konoguides.css" />
		<script src="../../../../../KonoMngr/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
  				TeX: { equationNumbers: { autoNumber: "AMS" } }
			});</script>
		<link rel="stylesheet" href="../../../../../KonoMngr/highlight/styles/googlecode.css">
		<script src="../../../../../KonoMngr/highlight/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>		
	</head>
	
	<body class="kg-content">
		<header>
			<h1>Classes and objects</h1>
		</header>
		
		<article class="subsection">		
			<p>Python has been an object-oriented language from day one. Because of this, creating and using classes and objects are downright easy.</p>
		</article>		

		<article class="subsection">			
			<h1>Creating classes</h1>
			<p>By convention, user-defined Python class names start with a capital letter.</p>
			<p> Ideally, you should define your classes in separate file then you should import them in your main program file using import statement.</p>
			<p>The class statement creates a new class definition. The name of the class immediately follows the keyword class followed by a colon as follows:</p>
			<pre><code>class Class_name(object):
	'Optional class documentation string'
 	class_suite</pre></code>
			<ul>
				<li><p>The class has a documentation string which can be access via ClassName.__doc__.</p></li>
				<li><p>The class_suite consists of all the component statements, defining class members, data attributes, and functions.</p></li>
			</ul>
			<p>Following is the example of a simple Python class:</p>
			<pre><code>class Animal(object):
	Common base class for all animals'
	animalCount = 0

	def __init__(self, name, family):
		self.name = name
		self.family = family
		Animal.animalCount += 1
   
	def displayTotal(self):
		print "Animal total %d" % Animal.animalCount

	def displayanimal(self):
		print "Name : ", self.name,  ", Family: ", self.family</pre></code>
			
			<ul>
				<li><p>The variable animalCount is a <em>class variable or member variable</em> cause it is available to all members of a class, so its <em>value</em> would <em>be shared among all instances of a this class</em>. This <em>can be accessed</em> as Animal.animalCount <em>from inside</em> the class <em>or outside</em> the class.</p></li>
				<li><p>The first method <em>__init__()</em> is a special method which is called <em>class constructor</em> or initialization method that Python calls when you create a new instance of this class.
	The <em>__init__()</em> function <em>is required</em> for classes, and it's used <em>to initialize the objects</em> it creates. __init__() <em>always takes at least one argument</em>, <em>self</em>, that refers to the object being created. You can think of __init__() as the function that "boots up" each object the class creates.</p></li>
				<li><p>You <em>declare other class methods</em> like <em>normal functions</em> with the exception that the <em>first argument to each method is self</em>. Python adds the self argument to the list for you; <em>you don't need to include it when you call</em> the methods.</p></li>
			</ul>

		</article>

		<article class="subsection">
			<h1>Creating instance objects</h1>
			<p>To create instances of a class, you call the class using class name and pass in whatever arguments its __init__ method accepts.</p>
			<pre><code>new_obj = Class_name(init_arg_1, init_arg_2, ..., init_arg_n)</pre></code>
		</article>

		<article class="subsection">
			<h1>Accessing attributes</h1>
			<p>An attribute is a object variable that holds data associated with the object. And it's a component of the object.</p>
			<p>You <em>access the object's attributes</em> using the <em>dot operator</em> with object.</p>
			<pre><code>new_obj.attribute_name</pre></code>
			<p>Instead of using the normal statements to access attributes, you can use following functions:</p>
     			<dl>
    				<dt>getattr(obj, name[, default])</dt>
    					<dd><p>to access the attribute of object.</p></dd>
    				<dt>hasattr(obj,name)</dt>
    					<dd><p>to check if an attribute exists or not.</p></dd>
    				<dt>setattr(obj,name,value)</dt>
    					<dd><p>to set an attribute. <em>If</em> attribute <em>does not exist</em> then it would be <em>created</em>.</p></dd>
    				<dt>delattr(obj, name)</dt>
    					<dd><p>to delete an attribute.</p></dd>
    			</dl>

			<h2>Built-in class attributes</h2>
			<p>Every Python class keeps following built-in attributes and they can be accessed using dot operator like any other attribute:</p>

    			<dl>
    				<dt>__dict__</dt>
  	  				<dd><p>Dictionary containing the class's namespace.</p></dd>
 		   		<dt>__doc__</dt>
  	  				<dd><p>Class documentation string, or None if undefined.</p></dd>
 		   		<dt>__name__</dt>
 		   			<dd><p>Class name.</p></dd>
  	  			<dt>__module__</dt>
  	  				<dd><p>Module name in which the class is defined. This attribute is "__main__" in interactive mode.</p></dd>
  	  			<dt>__bases__</dt>
  	  				<dd><p>A possibly empty tuple containing the base classes, in the order of their occurrence in the base class list.</p></dd>
  	  			<dt>__repr__</dt>
  	  				<dd><p>returns a representation of the object stored data. Providing a return value by overriding this method we can tell Python how to represent an object of our class (for instance, when using a print statement).</p></dd>
  	  </dl>
		</article>

		<article class="subsection">
			<h1>Calling methods</h1>
			<p>A method is a functions of an object. You <em>call the class methods</em> using the <em>dot operator</em> with object.</p>
			<pre><code>new_obj.method_name(...)</pre></code>
		</article>

		<article class="subsection">
			<h1>Destroying objects</h1>
			<p>Python deletes unneeded objects (built-in types or class instances) automatically to free memory space. The process by which Python periodically reclaims blocks of memory that no longer are in use is termed <em>garbage collection</em>.</p>

			<p>Python's garbage collector runs during program execution and is triggered when an object's reference count reaches zero. An object's reference count changes as the number of aliases that point to it changes:</p>

			<p>An object's reference count increases when it's assigned a new name or placed in a container (list, tuple, or dictionary). The object's reference count decreases when it's <em>deleted with del</em>, its reference is reassigned, or its reference goes out of scope. When an object's reference count reaches zero, Python collects it automatically.</p>

			<p>You normally won't notice when the garbage collector destroys an orphaned instance and reclaims its space. But a class <em>can implement the special method __del__()</em>, called a destructor, that is invoked when the instance is about to be destroyed. This method might be used to clean up any nonmemory resources used by an instance.</p>
		</article>

		<article class="subsection">
			<h1>Data hiding</h1>
			<p>An <em>object's attributes</em> may or <em>may not be visible outside the class</em> definition. For these cases, you can <em>name attributes with a double underscore prefix</em>, <em>and</em> those attributes <em>will not be directly visible</em> to outsiders. E.g.:</p>
			<pre><code>class JustCounter:
	__secretCount = 0

	def count(self):
		#functions suite</pre></code>
			
			<p>Python protects those members by internally changing the name to include the class name. You can access such attributes as:</p>
			<pre><code>print object._className__attrName</pre></code>

		</article>
	</body>
</html>

